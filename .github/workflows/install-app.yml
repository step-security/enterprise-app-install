name: Install GitHub App to Organizations

on:
  # Manual trigger with optional inputs
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - only check installation status without installing'
        required: false
        default: 'false'
        type: boolean
  # Scheduled run (daily at midnight UTC)
  schedule:
    - cron: '0 0 * * *'
  # Run when organizations.txt changes
  push:
    paths:
      - 'organizations.txt'

env:
  # Configure these values for your enterprise
  ENTERPRISE_SLUG: ${{ vars.ENTERPRISE_SLUG }}
  # Installer App - enterprise-level app with "Enterprise organization installations" permission
  INSTALLER_APP_CLIENT_ID: ${{ vars.INSTALLER_APP_CLIENT_ID }}
  # Target App - the app to be installed to organizations
  TARGET_APP_CLIENT_ID: ${{ vars.TARGET_APP_CLIENT_ID }}
  TARGET_APP_ID: ${{ vars.TARGET_APP_ID }}

jobs:
  install-app:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate JWT
        id: generate-jwt
        env:
          INSTALLER_APP_PRIVATE_KEY: ${{ secrets.INSTALLER_APP_PRIVATE_KEY }}
        run: |
          # Generate JWT for GitHub App authentication (using Installer App credentials)
          # Based on: https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/generating-a-json-web-token-jwt-for-a-github-app

          # Write private key to temp file (handles multi-line PEM format)
          KEY_FILE=$(mktemp)
          echo "${INSTALLER_APP_PRIVATE_KEY}" > "${KEY_FILE}"
          chmod 600 "${KEY_FILE}"
          trap "rm -f ${KEY_FILE}" EXIT

          NOW=$(date +%s)
          IAT=$((NOW - 60))  # Issued 60 seconds ago to allow for clock drift
          EXP=$((NOW + 600)) # Expires in 10 minutes

          # Helper function for base64url encoding
          b64enc() { openssl base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n'; }

          # Create JWT header
          HEADER=$(echo -n '{"typ":"JWT","alg":"RS256"}' | b64enc)

          # Create JWT payload (iss is the Installer App's Client ID)
          PAYLOAD=$(echo -n "{\"iat\":${IAT},\"exp\":${EXP},\"iss\":\"${INSTALLER_APP_CLIENT_ID}\"}" | b64enc)

          # Sign the JWT
          HEADER_PAYLOAD="${HEADER}.${PAYLOAD}"
          SIGNATURE=$(echo -n "${HEADER_PAYLOAD}" | openssl dgst -sha256 -sign "${KEY_FILE}" | b64enc)

          JWT="${HEADER_PAYLOAD}.${SIGNATURE}"
          echo "jwt=${JWT}" >> "$GITHUB_OUTPUT"
          echo "::add-mask::${JWT}"

      - name: Get Enterprise Installation ID
        id: get-installation
        env:
          JWT: ${{ steps.generate-jwt.outputs.jwt }}
        run: |
          # Get the app's installation ID for the enterprise
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${JWT}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Failed to get installations. HTTP $HTTP_CODE: $BODY"
            exit 1
          fi

          # Find the enterprise installation
          INSTALLATION_ID=$(echo "$BODY" | jq -r ".[] | select(.target_type == \"Enterprise\" and .account.slug == \"${ENTERPRISE_SLUG}\") | .id")

          if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" == "null" ]; then
            echo "::error::No enterprise installation found for ${ENTERPRISE_SLUG}"
            exit 1
          fi

          echo "installation_id=${INSTALLATION_ID}" >> "$GITHUB_OUTPUT"
          echo "Found enterprise installation ID: ${INSTALLATION_ID}"

      - name: Get Installation Access Token
        id: get-token
        env:
          JWT: ${{ steps.generate-jwt.outputs.jwt }}
          INSTALLATION_ID: ${{ steps.get-installation.outputs.installation_id }}
        run: |
          # Get an installation access token
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Authorization: Bearer ${JWT}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/${INSTALLATION_ID}/access_tokens")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" != "201" ]; then
            echo "::error::Failed to get access token. HTTP $HTTP_CODE: $BODY"
            exit 1
          fi

          TOKEN=$(echo "$BODY" | jq -r '.token')
          echo "token=${TOKEN}" >> "$GITHUB_OUTPUT"
          echo "::add-mask::${TOKEN}"
          echo "Successfully obtained installation access token"

      - name: Install App to Organizations
        env:
          ACCESS_TOKEN: ${{ steps.get-token.outputs.token }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
        run: |
          # Read organizations from file (skip comments and empty lines)
          ORGS=$(grep -v '^#' organizations.txt | grep -v '^[[:space:]]*$' || true)

          if [ -z "$ORGS" ]; then
            echo "::warning::No organizations found in organizations.txt"
            exit 0
          fi

          echo "=== Processing organizations ==="
          INSTALLED=0
          ALREADY_INSTALLED=0
          FAILED=0

          while IFS= read -r ORG; do
            # Trim whitespace
            ORG=$(echo "$ORG" | xargs)
            [ -z "$ORG" ] && continue

            echo ""
            echo "--- Processing: $ORG ---"

            # Check if app is already installed in this org (using enterprise API)
            CHECK_RESPONSE=$(curl -s -w "\n%{http_code}" \
              -H "Authorization: Bearer ${ACCESS_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/enterprises/${ENTERPRISE_SLUG}/apps/organizations/${ORG}/installations")

            CHECK_HTTP_CODE=$(echo "$CHECK_RESPONSE" | tail -n1)
            CHECK_BODY=$(echo "$CHECK_RESPONSE" | sed '$d')

            # Check if target app is already installed (compare with numeric TARGET_APP_ID)
            APP_INSTALLED=$(echo "$CHECK_BODY" | jq -r ".installations[]? | select(.app_id == ${TARGET_APP_ID}) | .id" 2>/dev/null || echo "")

            if [ -n "$APP_INSTALLED" ] && [ "$APP_INSTALLED" != "null" ]; then
              echo "App already installed in $ORG (installation ID: $APP_INSTALLED)"
              ALREADY_INSTALLED=$((ALREADY_INSTALLED + 1))
              continue
            fi

            if [ "$DRY_RUN" == "true" ]; then
              echo "[DRY RUN] Would install app to $ORG"
              continue
            fi

            # Install the target app to the organization
            INSTALL_RESPONSE=$(curl -s -w "\n%{http_code}" \
              -X POST \
              -H "Authorization: Bearer ${ACCESS_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -d "{\"client_id\":\"${TARGET_APP_CLIENT_ID}\",\"repository_selection\":\"all\"}" \
              "https://api.github.com/enterprises/${ENTERPRISE_SLUG}/apps/organizations/${ORG}/installations")

            INSTALL_HTTP_CODE=$(echo "$INSTALL_RESPONSE" | tail -n1)
            INSTALL_BODY=$(echo "$INSTALL_RESPONSE" | sed '$d')

            if [ "$INSTALL_HTTP_CODE" == "201" ] || [ "$INSTALL_HTTP_CODE" == "200" ]; then
              echo "Successfully installed app to $ORG"
              INSTALLED=$((INSTALLED + 1))
            elif [ "$INSTALL_HTTP_CODE" == "422" ]; then
              # 422 typically means already installed
              echo "App already installed in $ORG (confirmed via install attempt)"
              ALREADY_INSTALLED=$((ALREADY_INSTALLED + 1))
            else
              echo "::warning::Failed to install app to $ORG. HTTP $INSTALL_HTTP_CODE: $INSTALL_BODY"
              FAILED=$((FAILED + 1))
            fi

          done <<< "$ORGS"

          echo ""
          echo "=== Summary ==="
          echo "Newly installed: $INSTALLED"
          echo "Already installed: $ALREADY_INSTALLED"
          echo "Failed: $FAILED"

          if [ "$FAILED" -gt 0 ]; then
            echo "::warning::Some installations failed. Check the logs above for details."
          fi
