name: Install GitHub App to Organizations

on:
  # Manual trigger with optional inputs
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - only check installation status without installing'
        required: false
        default: 'false'
        type: boolean
  # Scheduled run (daily at midnight UTC)
  schedule:
    - cron: '0 0 * * *'
  # Run when organizations.txt changes
  push:
    paths:
      - 'organizations.txt'

env:
  # Configure these values for your enterprise
  ENTERPRISE_SLUG: ${{ vars.ENTERPRISE_SLUG }}
  # Installer App - enterprise-level app with "Enterprise organization installations" permission
  INSTALLER_APP_CLIENT_ID: ${{ vars.INSTALLER_APP_CLIENT_ID }}

permissions: {}

jobs:
  install-app:
    permissions:
      contents: read  # for actions/checkout to fetch code
    runs-on: ubuntu-latest
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Generate JWT
        id: generate-jwt
        env:
          INSTALLER_APP_PRIVATE_KEY: ${{ secrets.INSTALLER_APP_PRIVATE_KEY }}
        run: |
          # Generate JWT for GitHub App authentication (using Installer App credentials)
          # Based on: https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/generating-a-json-web-token-jwt-for-a-github-app

          # Write private key to temp file (handles multi-line PEM format)
          KEY_FILE=$(mktemp)
          echo "${INSTALLER_APP_PRIVATE_KEY}" > "${KEY_FILE}"
          chmod 600 "${KEY_FILE}"
          trap "rm -f ${KEY_FILE}" EXIT

          NOW=$(date +%s)
          IAT=$((NOW - 60))  # Issued 60 seconds ago to allow for clock drift
          EXP=$((NOW + 600)) # Expires in 10 minutes

          # Helper function for base64url encoding
          b64enc() { openssl base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n'; }

          # Create JWT header
          HEADER=$(echo -n '{"typ":"JWT","alg":"RS256"}' | b64enc)

          # Create JWT payload (iss is the Installer App's Client ID)
          PAYLOAD=$(echo -n "{\"iat\":${IAT},\"exp\":${EXP},\"iss\":\"${INSTALLER_APP_CLIENT_ID}\"}" | b64enc)

          # Sign the JWT
          HEADER_PAYLOAD="${HEADER}.${PAYLOAD}"
          SIGNATURE=$(echo -n "${HEADER_PAYLOAD}" | openssl dgst -sha256 -sign "${KEY_FILE}" | b64enc)

          JWT="${HEADER_PAYLOAD}.${SIGNATURE}"
          echo "jwt=${JWT}" >> "$GITHUB_OUTPUT"
          echo "::add-mask::${JWT}"

      - name: Get Enterprise Installation ID
        id: get-installation
        env:
          JWT: ${{ steps.generate-jwt.outputs.jwt }}
        run: |
          # Get the app's installation ID for the enterprise
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer ${JWT}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Failed to get installations. HTTP $HTTP_CODE: $BODY"
            exit 1
          fi

          # Find the enterprise installation
          INSTALLATION_ID=$(echo "$BODY" | jq -r ".[] | select(.target_type == \"Enterprise\" and .account.slug == \"${ENTERPRISE_SLUG}\") | .id")

          if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" == "null" ]; then
            echo "::error::No enterprise installation found for ${ENTERPRISE_SLUG}"
            exit 1
          fi

          echo "installation_id=${INSTALLATION_ID}" >> "$GITHUB_OUTPUT"
          echo "Found enterprise installation ID: ${INSTALLATION_ID}"

      - name: Get Installation Access Token
        id: get-token
        env:
          JWT: ${{ steps.generate-jwt.outputs.jwt }}
          INSTALLATION_ID: ${{ steps.get-installation.outputs.installation_id }}
        run: |
          # Get an installation access token
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Authorization: Bearer ${JWT}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/${INSTALLATION_ID}/access_tokens")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" != "201" ]; then
            echo "::error::Failed to get access token. HTTP $HTTP_CODE: $BODY"
            exit 1
          fi

          TOKEN=$(echo "$BODY" | jq -r '.token')
          echo "token=${TOKEN}" >> "$GITHUB_OUTPUT"
          echo "::add-mask::${TOKEN}"
          echo "Successfully obtained installation access token"

      - name: Install Apps to Organizations
        env:
          ACCESS_TOKEN: ${{ steps.get-token.outputs.token }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
        run: |
          # Define target apps to install
          declare -A APPS
          APPS["StepSecurity Actions Security App"]="Iv1.ad96d1f00234487b"
          APPS["StepSecurity App (Advanced App)"]="Iv23liR5Z8C22IM5THOA"

          # Read organizations from file (skip comments and empty lines)
          ORGS=$(grep -v '^#' organizations.txt | grep -v '^[[:space:]]*$' || true)

          if [ -z "$ORGS" ]; then
            echo "::warning::No organizations found in organizations.txt"
            exit 0
          fi

          echo "=== Processing organizations ==="
          echo "Apps to install: ${!APPS[*]}"
          echo ""

          INSTALLED=0
          ALREADY_INSTALLED=0
          FAILED=0

          while IFS= read -r ORG; do
            # Trim whitespace
            ORG=$(echo "$ORG" | xargs)
            [ -z "$ORG" ] && continue

            echo ""
            echo "=========================================="
            echo "Processing organization: $ORG"
            echo "=========================================="

            # Get current installations for this org
            CHECK_RESPONSE=$(curl -s -w "\n%{http_code}" \
              -H "Authorization: Bearer ${ACCESS_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/enterprises/${ENTERPRISE_SLUG}/apps/organizations/${ORG}/installations")

            CHECK_HTTP_CODE=$(echo "$CHECK_RESPONSE" | tail -n1)
            CHECK_BODY=$(echo "$CHECK_RESPONSE" | sed '$d')

            if [ "$CHECK_HTTP_CODE" != "200" ]; then
              echo "::warning::Failed to check installations for $ORG (HTTP $CHECK_HTTP_CODE)"
            fi

            # Process each app
            for APP_NAME in "${!APPS[@]}"; do
              APP_CLIENT_ID="${APPS[$APP_NAME]}"
              echo ""
              echo "--- $APP_NAME ($APP_CLIENT_ID) ---"

              # Check if this app is already installed
              APP_INSTALLED=$(echo "$CHECK_BODY" | jq -r ".[]? | select(.client_id == \"${APP_CLIENT_ID}\") | .id" 2>/dev/null || echo "")

              if [ -n "$APP_INSTALLED" ] && [ "$APP_INSTALLED" != "null" ]; then
                echo "Already installed (installation ID: $APP_INSTALLED)"
                ALREADY_INSTALLED=$((ALREADY_INSTALLED + 1))
                continue
              fi

              if [ "$DRY_RUN" == "true" ]; then
                echo "[DRY RUN] Would install"
                continue
              fi

              # Install the app
              INSTALL_RESPONSE=$(curl -s -w "\n%{http_code}" \
                -X POST \
                -H "Authorization: Bearer ${ACCESS_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                -d "{\"client_id\":\"${APP_CLIENT_ID}\",\"repository_selection\":\"all\"}" \
                "https://api.github.com/enterprises/${ENTERPRISE_SLUG}/apps/organizations/${ORG}/installations")

              INSTALL_HTTP_CODE=$(echo "$INSTALL_RESPONSE" | tail -n1)
              INSTALL_BODY=$(echo "$INSTALL_RESPONSE" | sed '$d')

              if [ "$INSTALL_HTTP_CODE" == "201" ] || [ "$INSTALL_HTTP_CODE" == "200" ]; then
                echo "Successfully installed"
                INSTALLED=$((INSTALLED + 1))
              elif [ "$INSTALL_HTTP_CODE" == "422" ]; then
                echo "Already installed (confirmed via install attempt)"
                ALREADY_INSTALLED=$((ALREADY_INSTALLED + 1))
              else
                echo "::warning::Failed to install. HTTP $INSTALL_HTTP_CODE: $INSTALL_BODY"
                FAILED=$((FAILED + 1))
              fi
            done

          done <<< "$ORGS"

          echo ""
          echo "=== Summary ==="
          echo "Newly installed: $INSTALLED"
          echo "Already installed: $ALREADY_INSTALLED"
          echo "Failed: $FAILED"

          if [ "$FAILED" -gt 0 ]; then
            echo "::warning::Some installations failed. Check the logs above for details."
          fi
